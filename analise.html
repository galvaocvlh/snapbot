<!doctype html> 
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTTS + Over 2.5 Analyzer — Campo Único + Normalizador (Flashscore)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark light; }
    /* Fallback da classe .badge para funcionar bem mesmo com Tailwind via CDN */
    .badge{
      display:inline-flex;align-items:center;border-radius:9999px;
      padding:2px 10px;font-size:.75rem;font-weight:600;line-height:1.2
    }
  </style>
</head>
<body class="bg-zinc-950 text-zinc-100 min-h-screen">

  <div class="max-w-6xl mx-auto p-6 space-y-6 pt-20">
    <header class="flex items-start justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">Analisador — Ambos Marcam (BTTS) + Over 2.5</h1>
        <p class="text-zinc-400 mt-1">
          Cole <strong>qualquer bloco bruto</strong> do Flashscore (com <em>Últimos jogos</em>, datas, siglas, "Mostrar mais jogos"...).
        </p>
      </div>

    </header>

    <section class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4 space-y-3">
      <h2 class="font-semibold">Entrada — <span class="text-emerald-300">Geral (colar do Flashscore, sem formatação)</span></h2>
      <textarea id="taUnified" rows="5" placeholder="Cole aqui todo o conteúdo bruto do Flashscore (Casa, Fora e Confrontos Diretos) — pode vir com datas, siglas e 'Mostrar mais jogos'." class="w-full bg-zinc-950 border border-zinc-800 rounded-xl p-3 text-sm"></textarea>
      <div class="flex items-center gap-4 text-sm text-zinc-400">
        <!-- Checkboxes removidos conforme solicitado -->
      </div>
    </section>

    <div class="flex items-center gap-3">
      <button id="btnAnalyze" class="px-4 py-2 rounded-xl bg-white text-black font-semibold hover:opacity-90 transition">Analisar</button>
      <button id="btnClear" class="px-4 py-2 rounded-xl bg-zinc-800 text-zinc-100 hover:bg-zinc-700 transition">Limpar</button>
    </div>

    <section id="detected" class="hidden bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4">
      <h3 class="font-semibold mb-2">Placar(es) detectados (após normalização)</h3>
      <div id="detectedTables" class="grid md:grid-cols-3 gap-4"></div>
      <p class="text-xs text-zinc-400 mt-3">Aqui você confere exatamente o que foi entendido a partir do texto colado (garantia de detecção ✅).</p>
    </section>

    <section id="results" class="hidden grid md:grid-cols-3 gap-4">
      <div id="cardHome" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardAway" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardH2H"  class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
    </section>

    <!-- DECISÃO com 3 estados: SIM / TALVEZ / NÃO -->
    <section id="decision" class="hidden bg-zinc-900/80 border border-zinc-700 rounded-2xl p-6 space-y-6">
      <div>
        <h3 class="text-xl font-bold mb-3">Veredito — BTTS</h3>
        <div id="verdictLineBTTS" class="mb-1"></div>
        <p id="infoBTTS" class="text-xs text-zinc-400"></p>
      </div>

      <div class="border-t border-zinc-700 pt-6">
        <h3 class="text-xl font-bold mb-3">Veredito — Over 2.5</h3>
        <div id="verdictLineO25" class="mb-1"></div>
        <p id="infoO25" class="text-xs text-zinc-400"></p>
      </div>
    </section>

    <footer class="pt-4 text-xs text-zinc-500">
      <p><strong>Observação importante:</strong> isto é um suporte estatístico amostral; não é conselho financeiro. Considere contexto (lesões, clima, odds, necessidade de resultado) antes de apostar.</p>
    </footer>
  </div>

  <script>
    // ===== Utilidades & Seletores =====
    const $ = (id) => document.getElementById(id);
    const startsWithI = (s, k) => s.trim().toLowerCase().startsWith(k.toLowerCase());
    const isScoreNum = (s) => /^\d{1,2}$/.test(s.trim());
    const isDate = (s) => /^\d{2}\.\d{2}\.\d{2}$/.test(s.trim());
    const isResultLetter = (s) => /^[VDE]$/i.test(s.trim());
    const isAllCapsShort = (s) => /^[A-Z]{2,5}$/.test(s.trim()); // SRA, LIB etc.
    const bannedLines = ["Mostrar mais jogos", "Mostrar mais", "Show more"];

    function isHeader(s){
      const t = s.trim();
      return startsWithI(t, "Últimos jogos") || startsWithI(t, "Ultimos jogos") || startsWithI(t, "Confrontos diretos");
    }
    function isNoise(t){
      if (!t.trim()) return true;
      if (bannedLines.some(b => startsWithI(t,b))) return true;
      if (isDate(t) || isAllCapsShort(t)) return true;
      return false;
    }
    function isTeamName(s){
      const t = s.trim();
      if (!t) return false;
      if (isNoise(t) || isScoreNum(t) || isResultLetter(t)) return false;
      if (!/[A-Za-zÀ-ú]/.test(t)) return false;
      if (t.length === 1) return false;
      return true;
    }
    function normalizeCase(name, lower){ return lower ? name.toLowerCase() : name; }

    // Converte sequência TeamA, TeamB, G1, G2, [V/D/E?] em "TeamA G1 x G2 TeamB"
    function parseLinesToMatches(lines, opts){
      const clean = lines.map(s=>s.replace(/\t/g,' ').trim()).filter(Boolean).filter(l => !bannedLines.some(b=>startsWithI(l,b)));
      const out = [];
      for (let i=0; i<clean.length-3; i++){
        const a = clean[i], b = clean[i+1], c = clean[i+2], d = clean[i+3];
        if (isTeamName(a) && isTeamName(b) && isScoreNum(c) && isScoreNum(d)){
          const res = clean[i+4] && isResultLetter(clean[i+4]) ? clean[i+4].toUpperCase() : null;
          out.push(`${normalizeCase(a, opts.lower)} ${c} x ${d} ${normalizeCase(b, opts.lower)}${opts.appendResult && res ? " - "+res : ""}`);
          i += (res ? 4 : 3);
        }
      }
      return {list: out};
    }

    // Divide o colado em 3 seções: 1º "Últimos jogos" → Casa; 2º "Últimos jogos" → Fora; "Confrontos diretos" → H2H
    function splitSections(all){
      const lines = all.split(/\r?\n/);
      const idxs = [];
      for (let i=0;i<lines.length;i++) if (isHeader(lines[i])) idxs.push({i, text: lines[i]});
      let secc = { casa: [], fora: [], h2h: [] };
      if (idxs.length === 0) return secc;
      const idxUJ = idxs.filter(h => startsWithI(h.text, "Últimos jogos") || startsWithI(h.text, "Ultimos jogos"));
      const idxH2H = idxs.find(h => startsWithI(h.text, "Confrontos diretos"));
      function sliceRange(start, end){ return lines.slice(start+1, end < 0 ? undefined : end); }
      if (idxUJ[0]){ const start = idxUJ[0].i; const end = idxUJ[1] ? idxUJ[1].i : (idxH2H ? idxH2H.i : -1); secc.casa = sliceRange(start, end); }
      if (idxUJ[1]){ const start = idxUJ[1].i; const end = idxH2H ? idxH2H.i : -1; secc.fora = sliceRange(start, end); }
      if (idxH2H){ const start = idxH2H.i; secc.h2h = sliceRange(start, -1); }
      return secc;
    }

    // ===== Extração de placares =====
    function extractInlineScores(lines){
      const out = [];
      const rx = /(\d{1,2})\s*[-:xX]\s*(\d{1,2})/; // 1-0, 1:0, 1 x 0
      for (const line of lines){
        const m = line.match(rx);
        if (m){
          const a = parseInt(m[1], 10), b = parseInt(m[2], 10);
          if (!isNaN(a)&&!isNaN(b)&&a<=20&&b<=20) out.push([a,b]);
        }
      }
      return out;
    }

    // ===== Estatísticas por conjunto =====
    function statsFrom(scores){
      const n = scores.length;
      if (n === 0) return {n:0, btts:0, pBTTS:NaN, over25:0, pO25:NaN, gpg:NaN, streakBTTS:0};
      let btts=0, over25=0, goals=0, streak=0;
      for (let i=0;i<n;i++){
        const [a,b] = scores[i];
        const isBTTS = a>0 && b>0;
        const isO25  = (a+b) >= 3;
        if (isBTTS) btts++;
        if (isO25)  over25++;
        streak = i===0 ? (isBTTS?1:0) : (isBTTS?streak+1:0);
        goals += a+b;
      }
      return { n, btts, pBTTS: btts/n, over25, pO25: over25/n, gpg: goals/n, streakBTTS: streak };
    }

    function pct(n){ return isFinite(n) ? (n*100).toFixed(1) + '%' : '—'; }
    function fairOdds(p){ return (p>0 ? (1/p).toFixed(2) : '—'); }

    function tableHTML(title, scores){
      if (!scores.length) return `<div class="text-zinc-500">Nenhum placar detectado.</div>`;
      const rows = scores.map(([a,b],i)=>`<tr class="hover:bg-zinc-900/50">
        <td class="px-2 py-1 text-zinc-400">#${i+1}</td>
        <td class="px-2 py-1 font-mono">${a}-${b}</td>
        <td class="px-2 py-1 ${a>0&&b>0?'text-emerald-300':'text-zinc-300'}">${a>0&&b>0?'BTTS':'—'}</td>
        <td class="px-2 py-1 ${a+b>=3?'text-emerald-300':'text-zinc-300'}">${a+b>=3?'O2.5':'—'}</td>
        <td class="px-2 py-1 text-zinc-300">${a+b}</td>
      </tr>`).join('');
      return `
        <div>
          <h4 class="font-semibold mb-2">${title}</h4>
          <table class="w-full text-sm border border-zinc-800 rounded-xl overflow-hidden">
            <thead class="bg-zinc-900/60">
              <tr>
                <th class="px-2 py-1 text-left text-zinc-400">Jogo</th>
                <th class="px-2 py-1 text-left text-zinc-400">Placar</th>
                <th class="px-2 py-1 text-left text-zinc-400">Ambos?</th>
                <th class="px-2 py-1 text-left text-zinc-400">O2.5?</th>
                <th class="px-2 py-1 text-left text-zinc-400">Gols</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }

    function cardHTML(label, st, color){
      const warn = st.n < 3 ? '<div class="text-amber-300 text-xs">Amostra pequena — resultados menos estáveis.</div>' : '';
      return `
        <div>
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">${label}</h3>
            <span class="badge ${color}">n=${st.n}</span>
          </div>
          ${warn}
          <ul class="text-sm space-y-1">
            <li>BTTS: <span class="font-semibold">${pct(st.pBTTS)}</span> (${st.btts}/${st.n})</li>
            <li>Over 2.5: <span class="font-semibold">${pct(st.pO25)}</span> (${st.over25}/${st.n})</li>
            <li>Gols por jogo: <span class="font-semibold">${isFinite(st.gpg)?st.gpg.toFixed(2):'—'}</span></li>
            <li>Streak BTTS (início da lista): <span class="font-semibold">${st.streakBTTS}</span></li>
          </ul>
        </div>`;
    }

    // ===== NOVAS FUNÇÕES: smoothing (Beta), intervalo Wilson, confiança =====
    function betaPosteriorMean(k, n, alpha=1, beta=1){
      return (k + alpha) / (n + alpha + beta);
    }
    function wilsonInterval(k, n, z=1.96){
      if (n === 0) return {p: NaN, lower: 0, upper: 1};
      const p = k / n;
      const z2 = z*z;
      const denom = 1 + z2/n;
      const centre = p + z2/(2*n);
      const rad = z * Math.sqrt((p*(1-p) + z2/(4*n)) / n);
      const lower = Math.max(0, (centre - rad) / denom);
      const upper = Math.min(1, (centre + rad) / denom);
      return {p, lower, upper};
    }
    function confidenceFromN(n, k=3){ return n / (n + k); }

    // ===== NOVO: Decisor TRI-ESTADO (SIM / TALVEZ / NÃO)
    // Regras:
    // - Limiar alto (SIM): 60% se N efetivo < 5; caso contrário 55%
    // - Limiar baixo (NÃO): 50% se N efetivo < 5; caso contrário 45%
    // - TALVEZ: intervalo entre os dois limiares ou quando não há dados
    function decideTri(p, effectiveN){
      const tHi = effectiveN < 5 ? 0.60 : 0.55;
      const tLo = effectiveN < 5 ? 0.50 : 0.45;
      if (!isFinite(p) || effectiveN === 0){
        return { verdict: 'TALVEZ', tHi, tLo, reason: 'sem dados suficientes' };
      }
      let verdict = 'TALVEZ';
      if (p >= tHi) verdict = 'SIM';
      else if (p <= tLo) verdict = 'NÃO';
      return { verdict, tHi, tLo, reason: `effectiveN=${effectiveN}` };
    }

    function analyze(){
      const raw = $("taUnified").value || "";
      const lower = false;
      const appendResult = false;

      // 1) Normaliza → separa em Casa/Fora/H2H
      const secc = splitSections(raw);
      const casaNorm = parseLinesToMatches(secc.casa, { lower, appendResult }).list;
      const foraNorm = parseLinesToMatches(secc.fora, { lower, appendResult }).list;
      const h2hNorm  = parseLinesToMatches(secc.h2h,  { lower, appendResult }).list;

      // 2) Extrai os scores
      const scHome = extractInlineScores(casaNorm);
      const scAway = extractInlineScores(foraNorm);
      const scH2H  = extractInlineScores(h2hNorm);

      // Mostrar detecção
      $("detected").classList.remove('hidden');
      $("detectedTables").innerHTML = [
        tableHTML('CASA — placares detectados', scHome),
        tableHTML('FORA — placares detectados', scAway),
        tableHTML('H2H — placares detectados', scH2H),
      ].join('');

      // 3) Estatísticas
      const stH = statsFrom(scHome);
      const stA = statsFrom(scAway);
      const stD = statsFrom(scH2H);

      $("results").classList.remove('hidden');
      $("cardHome").innerHTML = cardHTML('CASA (últimos 5)', stH, 'bg-emerald-900/40 text-emerald-100');
      $("cardAway").innerHTML = cardHTML('FORA (últimos 5)', stA, 'bg-sky-900/40 text-sky-100');
      $("cardH2H").innerHTML  = cardHTML('H2H (últimos 5)',  stD, 'bg-amber-900/40 text-amber-100');

      // pesos base
      const wH_base = 0.4;
      const wA_base = 0.4;
      const wD_base = 0.2;

      // suavização Beta por fonte
      const pH_post = betaPosteriorMean(stH.btts, stH.n, 1, 1);
      const pA_post = betaPosteriorMean(stA.btts, stA.n, 1, 1);
      const pD_post = betaPosteriorMean(stD.btts, stD.n, 1, 1);

      const pH_o_post = betaPosteriorMean(stH.over25, stH.n, 1, 1);
      const pA_o_post = betaPosteriorMean(stA.over25, stA.n, 1, 1);
      const pD_o_post = betaPosteriorMean(stD.over25, stD.n, 1, 1);

      // confiança por n
      const cH = confidenceFromN(stH.n, 3), cA = confidenceFromN(stA.n, 3), cD = confidenceFromN(stD.n, 3);

      // pesos ajustados por confiança
      let wH = wH_base * cH, wA = wA_base * cA, wD = wD_base * cD;
      const sumW_conf = (wH + wA + wD) || 1;
      wH /= sumW_conf; wA /= sumW_conf; wD /= sumW_conf;

      const effectiveN = stH.n + stA.n + stD.n;

      // ===== BTTS combinado
      const baseBTTS = (wH * pH_post + wA * pA_post + wD * pD_post);
      const avgG_list = [stH.gpg, stA.gpg, stD.gpg].filter(Number.isFinite);
      const meanG = avgG_list.length ? avgG_list.reduce((a,b)=>a+b,0)/avgG_list.length : 2.6;
      const factorGoalsBTTS = Math.min(1.2, Math.max(0.8, meanG / 2.6));
      let pBTTS = Math.min(1, Math.max(0, baseBTTS * factorGoalsBTTS));
      if (pH_post>=0.55 && pA_post>=0.55 && pD_post>=0.55) pBTTS = Math.min(1, pBTTS + 0.05);

      // intervalo Wilson informativo (aprox. com N efetivo)
      const wiBTTS = wilsonInterval(Math.round(pBTTS * effectiveN), effectiveN);

      // decisão TRI para BTTS
      const triBTTS = decideTri(pBTTS, effectiveN);
      const badgeBTTSClass =
        triBTTS.verdict === 'SIM' ? 'bg-emerald-700 text-emerald-100' :
        triBTTS.verdict === 'NÃO' ? 'bg-rose-700 text-rose-100' :
        'bg-amber-600 text-amber-100';
      const emojiBTTS =
        triBTTS.verdict === 'SIM' ? '✅' :
        triBTTS.verdict === 'NÃO' ? '⛔' : '🟡';

      $("decision").classList.remove('hidden');
      $("verdictLineBTTS").innerHTML = `
        <div class="flex flex-wrap items-center gap-3">
          <span class="badge ${badgeBTTSClass} text-sm">${emojiBTTS} ${triBTTS.verdict}</span>
          <div class="text-zinc-300 text-sm">
            Prob: <strong>${pct(pBTTS)}</strong>
            • Limiar SIM ≥ ${(triBTTS.tHi*100).toFixed(0)}%
            • TALVEZ ${Math.round(triBTTS.tLo*100)}–${Math.round(triBTTS.tHi*100)}%
            • NÃO ≤ ${(triBTTS.tLo*100).toFixed(0)}%
            — ${triBTTS.reason}
          </div>
        </div>`;
      $("infoBTTS").innerText =
        `Fonte (suavizado): Casa ${pct(pH_post)} (n=${stH.n}), Fora ${pct(pA_post)} (n=${stA.n}), H2H ${pct(pD_post)} (n=${stD.n}). `
        + `GPG médio: ${isFinite(meanG)?meanG.toFixed(2):'—'}. `
        + `IC95%~BTTS: [${pct(wiBTTS.lower)}–${pct(wiBTTS.upper)}]. Odds justas≈ ${fairOdds(pBTTS)}.`;

      // ===== Over 2.5 combinado
      const baseO25 = (wH * pH_o_post + wA * pA_o_post + wD * pD_o_post);
      const factorGoalsO25 = Math.min(1.25, Math.max(0.75, meanG / 2.6));
      let pO25 = Math.min(1, Math.max(0, baseO25 * factorGoalsO25));
      if (meanG >= 2.9) pO25 = Math.min(1, pO25 + 0.03);

      const wiO25 = wilsonInterval(Math.round(pO25 * effectiveN), effectiveN);

      const triO25 = decideTri(pO25, effectiveN);
      const badgeO25Class =
        triO25.verdict === 'SIM' ? 'bg-emerald-700 text-emerald-100' :
        triO25.verdict === 'NÃO' ? 'bg-rose-700 text-rose-100' :
        'bg-amber-600 text-amber-100';
      const emojiO25 =
        triO25.verdict === 'SIM' ? '✅' :
        triO25.verdict === 'NÃO' ? '⛔' : '🟡';

      $("verdictLineO25").innerHTML = `
        <div class="flex flex-wrap items-center gap-3">
          <span class="badge ${badgeO25Class} text-sm">${emojiO25} ${triO25.verdict}</span>
          <div class="text-zinc-300 text-sm">
            Prob: <strong>${pct(pO25)}</strong>
            • Limiar SIM ≥ ${(triO25.tHi*100).toFixed(0)}%
            • TALVEZ ${Math.round(triO25.tLo*100)}–${Math.round(triO25.tHi*100)}%
            • NÃO ≤ ${(triO25.tLo*100).toFixed(0)}%
            — ${triO25.reason}
          </div>
        </div>`;
      $("infoO25").innerText =
        `Fonte (suavizado): Casa ${pct(pH_o_post)} (n=${stH.n}), Fora ${pct(pA_o_post)} (n=${stA.n}), H2H ${pct(pD_o_post)} (n=${stD.n}). `
        + `GPG médio: ${isFinite(meanG)?meanG.toFixed(2):'—'}. `
        + `IC95%~O2.5: [${pct(wiO25.lower)}–${pct(wiO25.upper)}]. Odds justas≈ ${fairOdds(pO25)}.`;
    }

    $("btnAnalyze").addEventListener('click', analyze);
    $("btnClear").addEventListener('click', () => {
      $("taUnified").value = '';
      ["results","decision","detected"].forEach(id=>$(id).classList.add('hidden'));
      $("detectedTables").innerHTML = '';
      ["cardHome","cardAway","cardH2H","verdictLineBTTS","verdictLineO25","infoBTTS","infoO25"].forEach(id=>{ const el = $(id); if (el) el.innerHTML = ''; });
    });
  </script>
</body>
</html>
