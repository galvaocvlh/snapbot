<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTTS + Over 2.5 Analyzer — Campo Único + Normalizador (Flashscore)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark light; }
    .badge { @apply inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium; }
  </style>
</head>
<body class="bg-zinc-950 text-zinc-100 min-h-screen">

  <div class="max-w-6xl mx-auto p-6 space-y-6 pt-20">
    <header class="flex items-start justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">Analisador — Ambos Marcam (BTTS) + Over 2.5</h1>
        <p class="text-zinc-400 mt-1">
          Cole <strong>qualquer bloco bruto</strong> do Flashscore (com <em>Últimos jogos</em>, datas, siglas, "Mostrar mais jogos"...).
        </p>
      </div>

    </header>

    <section class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4 space-y-3">
      <h2 class="font-semibold">Entrada — <span class="text-emerald-300">Geral (colar do Flashscore, sem formatação)</span></h2>
      <textarea id="taUnified" rows="5" placeholder="Cole aqui todo o conteúdo bruto do Flashscore (Casa, Fora e Confrontos Diretos) — pode vir com datas, siglas e 'Mostrar mais jogos'." class="w-full bg-zinc-950 border border-zinc-800 rounded-xl p-3 text-sm"></textarea>
      <div class="flex items-center gap-4 text-sm text-zinc-400">
        <label class="flex items-center gap-2"><input id="optLower" type="checkbox" class="accent-emerald-400"> converter nomes para minúsculas</label>
        <label class="flex items-center gap-2"><input id="optResultSuffix" type="checkbox" class="accent-emerald-400"> manter sufixo de resultado ( - V/D/E) quando existir</label>
      </div>
    </section>

    <div class="flex items-center gap-3">
      <button id="btnAnalyze" class="px-4 py-2 rounded-xl bg-white text-black font-semibold hover:opacity-90 transition">Analisar</button>
      <button id="btnClear" class="px-4 py-2 rounded-xl bg-zinc-800 text-zinc-100 hover:bg-zinc-700 transition">Limpar</button>
    </div>

    <section id="detected" class="hidden bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4">
      <h3 class="font-semibold mb-2">Placar(es) detectados (após normalização)</h3>
      <div id="detectedTables" class="grid md:grid-cols-3 gap-4"></div>
      <p class="text-xs text-zinc-400 mt-3">Aqui você confere exatamente o que foi entendido a partir do texto colado (garantia de detecção ✅).</p>
    </section>

    <section id="results" class="hidden grid md:grid-cols-3 gap-4">
      <div id="cardHome" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardAway" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardH2H"  class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
    </section>

    <section id="decision" class="hidden bg-zinc-900/80 border border-zinc-700 rounded-2xl p-6 space-y-6">
      <div>
        <h3 class="text-xl font-bold mb-3">Ambos Marcam</h3>
        <div id="verdictLineBTTS" class="mb-3"></div>
        <div class="grid md:grid-cols-2 gap-4 text-sm">
          <div>
            <h4 class="font-semibold mb-1">Cálculo (estilo tipster)</h4>
            <ul id="calcListBTTS" class="list-disc pl-6 space-y-1 text-zinc-300"></ul>
          </div>
          <div>
            <h4 class="font-semibold mb-1">Regras de decisão</h4>
            <ul class="list-disc pl-6 space-y-1 text-zinc-300">
              <li><span class="badge bg-emerald-900/50 text-emerald-200">Forte</span>: p ≥ 60% e Casa &amp; Fora ≥ 55%.</li>
              <li><span class="badge bg-amber-900/40 text-amber-200">Leve</span>: 52% ≤ p &lt; 60%.</li>
              <li><span class="badge bg-zinc-800 text-zinc-200">Neutro</span>: faixa intermediária não-criteriosa.</li>
              <li><span class="badge bg-rose-900/50 text-rose-200">Ruim</span>: p ≤ 48% ou ≥2 fontes ≤ 40%.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="border-t border-zinc-700 pt-6">
        <h3 class="text-xl font-bold mb-3">Mais 2.5</h3>
        <div id="verdictLineO25" class="mb-3"></div>
        <div class="grid md:grid-cols-2 gap-4 text-sm">
          <div>
            <h4 class="font-semibold mb-1">Cálculo (estilo tipster)</h4>
            <ul id="calcListO25" class="list-disc pl-6 space-y-1 text-zinc-300"></ul>
          </div>
          <div>
            <h4 class="font-semibold mb-1">Regras de decisão</h4>
            <ul class="list-disc pl-6 space-y-1 text-zinc-300">
              <li><span class="badge bg-emerald-900/50 text-emerald-200">Forte</span>: p ≥ 60% e GPG médio ≥ 2.70.</li>
              <li><span class="badge bg-amber-900/40 text-amber-200">Leve</span>: 52% ≤ p &lt; 60%.</li>
              <li><span class="badge bg-zinc-800 text-zinc-200">Neutro</span>: faixa intermediária não-criteriosa.</li>
              <li><span class="badge bg-rose-900/50 text-rose-200">Ruim</span>: p ≤ 48% ou ≥2 fontes ≤ 40%.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <footer class="pt-4 text-xs text-zinc-500">
      <p><strong>Observação importante:</strong> isto é um suporte estatístico amostral; não é conselho financeiro. Considere contexto (lesões, clima, odds, necessidade de resultado) antes de apostar.</p>
    </footer>
  </div>

  <script>
    // ===== Utilidades & Seletores =====
    const $ = (id) => document.getElementById(id);
    const startsWithI = (s, k) => s.trim().toLowerCase().startsWith(k.toLowerCase());
    const isScoreNum = (s) => /^\d{1,2}$/.test(s.trim());
    const isDate = (s) => /^\d{2}\.\d{2}\.\d{2}$/.test(s.trim());
    const isResultLetter = (s) => /^[VDE]$/i.test(s.trim());
    const isAllCapsShort = (s) => /^[A-Z]{2,5}$/.test(s.trim()); // SRA, LIB etc.
    const bannedLines = ["Mostrar mais jogos", "Mostrar mais", "Show more"];

    function isHeader(s){
      const t = s.trim();
      return startsWithI(t, "Últimos jogos") || startsWithI(t, "Ultimos jogos") || startsWithI(t, "Confrontos diretos");
    }
    function isNoise(t){
      if (!t.trim()) return true;
      if (bannedLines.some(b => startsWithI(t,b))) return true;
      if (isDate(t) || isAllCapsShort(t)) return true;
      return false;
    }
    function isTeamName(s){
      const t = s.trim();
      if (!t) return false;
      if (isNoise(t) || isScoreNum(t) || isResultLetter(t)) return false;
      if (!/[A-Za-zÀ-ú]/.test(t)) return false;
      if (t.length === 1) return false;
      return true;
    }
    function normalizeCase(name, lower){ return lower ? name.toLowerCase() : name; }

    // Converte sequência TeamA, TeamB, G1, G2, [V/D/E?] em "TeamA G1 x G2 TeamB"
    function parseLinesToMatches(lines, opts){
      const clean = lines.map(s=>s.replace(/\t/g,' ').trim()).filter(Boolean).filter(l => !bannedLines.some(b=>startsWithI(l,b)));
      const out = [];
      for (let i=0; i<clean.length-3; i++){
        const a = clean[i], b = clean[i+1], c = clean[i+2], d = clean[i+3];
        if (isTeamName(a) && isTeamName(b) && isScoreNum(c) && isScoreNum(d)){
          const res = clean[i+4] && isResultLetter(clean[i+4]) ? clean[i+4].toUpperCase() : null;
          out.push(`${normalizeCase(a, opts.lower)} ${c} x ${d} ${normalizeCase(b, opts.lower)}${opts.appendResult && res ? " - "+res : ""}`);
          i += (res ? 4 : 3);
        }
      }
      return {list: out};
    }

    // Divide o colado em 3 seções: 1º "Últimos jogos" → Casa; 2º "Últimos jogos" → Fora; "Confrontos diretos" → H2H
    function splitSections(all){
      const lines = all.split(/\r?\n/);
      const idxs = [];
      for (let i=0;i<lines.length;i++) if (isHeader(lines[i])) idxs.push({i, text: lines[i]});
      let secc = { casa: [], fora: [], h2h: [] };
      if (idxs.length === 0) return secc;
      const idxUJ = idxs.filter(h => startsWithI(h.text, "Últimos jogos") || startsWithI(h.text, "Ultimos jogos"));
      const idxH2H = idxs.find(h => startsWithI(h.text, "Confrontos diretos"));
      function sliceRange(start, end){ return lines.slice(start+1, end < 0 ? undefined : end); }
      if (idxUJ[0]){ const start = idxUJ[0].i; const end = idxUJ[1] ? idxUJ[1].i : (idxH2H ? idxH2H.i : -1); secc.casa = sliceRange(start, end); }
      if (idxUJ[1]){ const start = idxUJ[1].i; const end = idxH2H ? idxH2H.i : -1; secc.fora = sliceRange(start, end); }
      if (idxH2H){ const start = idxH2H.i; secc.h2h = sliceRange(start, -1); }
      return secc;
    }

    // ===== Extração de placares =====
    function extractInlineScores(lines){
      const out = [];
      const rx = /(\d{1,2})\s*[-:xX]\s*(\d{1,2})/; // 1-0, 1:0, 1 x 0
      for (const line of lines){
        const m = line.match(rx);
        if (m){
          const a = parseInt(m[1], 10), b = parseInt(m[2], 10);
          if (!isNaN(a)&&!isNaN(b)&&a<=20&&b<=20) out.push([a,b]);
        }
      }
      return out;
    }

    // ===== Estatísticas por conjunto =====
    function statsFrom(scores){
      const n = scores.length;
      if (n === 0) return {n:0, btts:0, pBTTS:NaN, over25:0, pO25:NaN, gpg:NaN, streakBTTS:0};
      let btts=0, over25=0, goals=0, streak=0;
      for (let i=0;i<n;i++){
        const [a,b] = scores[i];
        const isBTTS = a>0 && b>0;
        const isO25  = (a+b) >= 3;
        if (isBTTS) btts++;
        if (isO25)  over25++;
        streak = i===0 ? (isBTTS?1:0) : (isBTTS?streak+1:0);
        goals += a+b;
      }
      return { n, btts, pBTTS: btts/n, over25, pO25: over25/n, gpg: goals/n, streakBTTS: streak };
    }

    function pct(n){ return isFinite(n) ? (n*100).toFixed(1) + '%' : '—'; }
    function fairOdds(p){ return (p>0 ? (1/p).toFixed(2) : '—'); }

    function tableHTML(title, scores){
      if (!scores.length) return `<div class="text-zinc-500">Nenhum placar detectado.</div>`;
      const rows = scores.map(([a,b],i)=>`<tr class="hover:bg-zinc-900/50">
        <td class="px-2 py-1 text-zinc-400">#${i+1}</td>
        <td class="px-2 py-1 font-mono">${a}-${b}</td>
        <td class="px-2 py-1 ${a>0&&b>0?'text-emerald-300':'text-zinc-300'}">${a>0&&b>0?'BTTS':'—'}</td>
        <td class="px-2 py-1 ${a+b>=3?'text-emerald-300':'text-zinc-300'}">${a+b>=3?'O2.5':'—'}</td>
        <td class="px-2 py-1 text-zinc-300">${a+b}</td>
      </tr>`).join('');
      return `
        <div>
          <h4 class="font-semibold mb-2">${title}</h4>
          <table class="w-full text-sm border border-zinc-800 rounded-xl overflow-hidden">
            <thead class="bg-zinc-900/60">
              <tr>
                <th class="px-2 py-1 text-left text-zinc-400">Jogo</th>
                <th class="px-2 py-1 text-left text-zinc-400">Placar</th>
                <th class="px-2 py-1 text-left text-zinc-400">Ambos?</th>
                <th class="px-2 py-1 text-left text-zinc-400">O2.5?</th>
                <th class="px-2 py-1 text-left text-zinc-400">Gols</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }

    function cardHTML(label, st, color){
      const warn = st.n < 3 ? '<div class="text-amber-300 text-xs">Amostra pequena — resultados menos estáveis.</div>' : '';
      return `
        <div>
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">${label}</h3>
            <span class="badge ${color}">n=${st.n}</span>
          </div>
          ${warn}
          <ul class="text-sm space-y-1">
            <li>BTTS: <span class="font-semibold">${pct(st.pBTTS)}</span> (${st.btts}/${st.n})</li>
            <li>Over 2.5: <span class="font-semibold">${pct(st.pO25)}</span> (${st.over25}/${st.n})</li>
            <li>Gols por jogo: <span class="font-semibold">${isFinite(st.gpg)?st.gpg.toFixed(2):'—'}</span></li>
            <li>Streak BTTS (início da lista): <span class="font-semibold">${st.streakBTTS}</span></li>
          </ul>
        </div>`;
    }

    function decideVerdictBTTS(p, pH, pA, pD){
      let label = 'Neutro', cls = 'bg-zinc-800 text-zinc-100', emoji='⚖️';
      if (p <= 0.48 || [pH,pA,pD].filter(x=>x<=0.40).length >= 2) { label = 'Ruim'; cls='bg-rose-900/60 text-rose-100'; emoji='⛔'; }
      else if (p >= 0.60 && pH>=0.55 && pA>=0.55) { label='Forte'; cls='bg-emerald-900/60 text-emerald-100'; emoji='🔥'; }
      else if (p >= 0.52 && p < 0.60) { label='Leve'; cls='bg-amber-900/60 text-amber-100'; emoji='✨'; }
      return {label, cls, emoji};
    }
    function decideVerdictO25(p, meanG, pH, pA, pD){
      let label = 'Neutro', cls = 'bg-zinc-800 text-zinc-100', emoji='⚖️';
      if (p <= 0.48 || [pH,pA,pD].filter(x=>x<=0.40).length >= 2) { label = 'Ruim'; cls='bg-rose-900/60 text-rose-100'; emoji='⛔'; }
      else if (p >= 0.60 && isFinite(meanG) && meanG >= 2.70) { label='Forte'; cls='bg-emerald-900/60 text-emerald-100'; emoji='🔥'; }
      else if (p >= 0.52 && p < 0.60) { label='Leve'; cls='bg-amber-900/60 text-amber-100'; emoji='✨'; }
      return {label, cls, emoji};
    }

    function analyze(){
      const raw = $("taUnified").value || "";
      const lower = $("optLower").checked;
      const appendResult = $("optResultSuffix").checked;

      // 1) Normaliza → separa em Casa/Fora/H2H
      const secc = splitSections(raw);
      const casaNorm = parseLinesToMatches(secc.casa, { lower, appendResult }).list;
      const foraNorm = parseLinesToMatches(secc.fora, { lower, appendResult }).list;
      const h2hNorm  = parseLinesToMatches(secc.h2h,  { lower, appendResult }).list;

      // 2) Extrai os scores
      const scHome = extractInlineScores(casaNorm);
      const scAway = extractInlineScores(foraNorm);
      const scH2H  = extractInlineScores(h2hNorm);

      // Mostrar detecção
      $("detected").classList.remove('hidden');
      $("detectedTables").innerHTML = [
        tableHTML('CASA — placares detectados', scHome),
        tableHTML('FORA — placares detectados', scAway),
        tableHTML('H2H — placares detectados', scH2H),
      ].join('');

      // 3) Estatísticas
      const stH = statsFrom(scHome);
      const stA = statsFrom(scAway);
      const stD = statsFrom(scH2H);

      $("results").classList.remove('hidden');
      $("cardHome").innerHTML = cardHTML('CASA (últimos 5)', stH, 'bg-emerald-900/40 text-emerald-100');
      $("cardAway").innerHTML = cardHTML('FORA (últimos 5)', stA, 'bg-sky-900/40 text-sky-100');
      $("cardH2H").innerHTML  = cardHTML('H2H (últimos 5)',  stD, 'bg-amber-900/40 text-amber-100');

// Pesos fixos (não precisam de input)
const wH = 0.4;   // peso jogos em casa
const wA = 0.4;   // peso jogos fora
const wD = 0.2;   // peso confrontos diretos
const sumW = wH + wA + wD;

      // BTTS combinado
      const pH = stH.pBTTS || 0, pA = stA.pBTTS || 0, pD = stD.pBTTS || 0;
      const baseBTTS = (wH * pH + wA * pA + wD * pD) / sumW;
      const avgG_list = [stH.gpg, stA.gpg, stD.gpg].filter(Number.isFinite);
      const meanG = avgG_list.length ? avgG_list.reduce((a,b)=>a+b,0)/avgG_list.length : 2.6;
      const factorGoalsBTTS = Math.min(1.2, Math.max(0.8, meanG / 2.6)); // baseline 2.6 g/jogo
      let pBTTS = Math.min(1, Math.max(0, baseBTTS * factorGoalsBTTS));
      if (pH>=0.55 && pA>=0.55 && pD>=0.55) pBTTS = Math.min(1, pBTTS + 0.05);
      const {label: labB, cls: clsB, emoji: emB} = decideVerdictBTTS(pBTTS, pH, pA, pD);

      $("decision").classList.remove('hidden');
      $("verdictLineBTTS").innerHTML = `
        <div class="flex flex-wrap items-center gap-2">
          <span class="badge ${clsB}">${emB} ${labB}</span>
          <span class="text-zinc-300">Prob. combinada (p): <span class="font-semibold">${pct(pBTTS)}</span></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Casa: <strong>${pct(pH)}</strong></span>
          <span class="text-zinc-300">Fora: <strong>${pct(pA)}</strong></span>
          <span class="text-zinc-300">H2H: <strong>${pct(pD)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-400">Gols médios: <strong>${isFinite(meanG)?meanG.toFixed(2):'—'}</strong> (fator ${factorGoalsBTTS.toFixed(2)})</span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Fair odds (sem margem): <strong>${fairOdds(pBTTS)}</strong></span>
        </div>`;

      $("calcListBTTS").innerHTML = `
        <li><strong>p base (BTTS)</strong> = (wC·pC + wF·pF + wH2H·pH2H) / soma dos pesos = <code>${(baseBTTS*100).toFixed(1)}%</code></li>
        <li><strong>fator de gols</strong> = média(GPG fontes) / 2.6 → limitado a [0.80, 1.20] = <code>${factorGoalsBTTS.toFixed(2)}</code></li>
        <li><strong>p ajustado</strong> = clamp(p base × fator [+5 p.p. se 3 fontes ≥55%]) = <code>${(pBTTS*100).toFixed(1)}%</code></li>`;

      // Over 2.5 combinado
      const pH_o = stH.pO25 || 0, pA_o = stA.pO25 || 0, pD_o = stD.pO25 || 0;
      const baseO25 = (wH * pH_o + wA * pA_o + wD * pD_o) / sumW;
      const factorGoalsO25 = Math.min(1.25, Math.max(0.75, meanG / 2.6)); // dá um pouco mais de amplitude
      let pO25 = Math.min(1, Math.max(0, baseO25 * factorGoalsO25));
      if (meanG >= 2.9) pO25 = Math.min(1, pO25 + 0.03); // bônus suave em cenários muito over
      const {label: labO, cls: clsO, emoji: emO} = decideVerdictO25(pO25, meanG, pH_o, pA_o, pD_o);

      $("verdictLineO25").innerHTML = `
        <div class="flex flex-wrap items-center gap-2">
          <span class="badge ${clsO}">${emO} ${labO}</span>
          <span class="text-zinc-300">Prob. combinada (p): <span class="font-semibold">${pct(pO25)}</span></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Casa: <strong>${pct(pH_o)}</strong></span>
          <span class="text-zinc-300">Fora: <strong>${pct(pA_o)}</strong></span>
          <span class="text-zinc-300">H2H: <strong>${pct(pD_o)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-400">Gols médios: <strong>${isFinite(meanG)?meanG.toFixed(2):'—'}</strong> (fator ${factorGoalsO25.toFixed(2)})</span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Fair odds (sem margem): <strong>${fairOdds(pO25)}</strong></span>
        </div>`;

      $("calcListO25").innerHTML = `
        <li><strong>p base (Over 2.5)</strong> = (wC·pC + wF·pF + wH2H·pH2H) / soma dos pesos = <code>${(baseO25*100).toFixed(1)}%</code></li>
        <li><strong>fator de gols</strong> = média(GPG fontes) / 2.6 → limitado a [0.75, 1.25] = <code>${factorGoalsO25.toFixed(2)}</code></li>
        <li><strong>p ajustado</strong> = clamp(p base × fator [+3 p.p. se GPG ≥ 2.9]) = <code>${(pO25*100).toFixed(1)}%</code></li>`;
    }

    $("btnAnalyze").addEventListener('click', analyze);
    $("btnClear").addEventListener('click', () => {
      $("taUnified").value = '';
      ["results","decision","detected"].forEach(id=>$(id).classList.add('hidden'));
      $("detectedTables").innerHTML = '';
      ["cardHome","cardAway","cardH2H","verdictLineBTTS","calcListBTTS","verdictLineO25","calcListO25"].forEach(id=>{ const el = $(id); if (el) el.innerHTML = ''; });
      $("optLower").checked = false;
      $("optResultSuffix").checked = false;
    });
  </script>
</body>
</html>
