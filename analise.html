<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTTS + Over 2.5 Analyzer — Campo Único + Normalizador (Flashscore)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark light; }
    .badge { @apply inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium; }
  </style>
</head>
<body class="bg-zinc-950 text-zinc-100 min-h-screen">

  <div class="max-w-6xl mx-auto p-6 space-y-6 pt-20">
    <header class="flex items-start justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">Analisador — Ambos Marcam (BTTS) + Over 2.5</h1>
        <p class="text-zinc-400 mt-1">
          Cole <strong>os blocos bruto</strong> do Flashscore (com <em>Últimos jogos</em>, datas, siglas, "Mostrar mais jogos"...)
      </p>
      </div>
      <div class="text-right">
        <label class="text-sm text-zinc-400">Pesos (Casa / Fora / H2H)</label>
        <div class="flex items-center gap-2 mt-2">
          <input id="wHome" type="number" class="w-16 bg-zinc-900 border border-zinc-700 rounded px-2 py-1" value="0.4" step="0.05" min="0" max="1">
          <input id="wAway" type="number" class="w-16 bg-zinc-900 border border-zinc-700 rounded px-2 py-1" value="0.4" step="0.05" min="0" max="1">
          <input id="wH2H"  type="number" class="w-16 bg-zinc-900 border border-zinc-700 rounded px-2 py-1" value="0.2" step="0.05" min="0" max="1">
        </div>
        <p class="text-xs text-zinc-500 mt-1">A soma deve ser ≈ 1.0</p>
      </div>
    </header>

    <section class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4 space-y-3">
      <h2 class="font-semibold">Entrada — <span class="text-emerald-300">Geral (colar do Flashscore, sem formatação)</span></h2>
      <textarea id="taUnified" rows="2" placeholder="Cole aqui todo o conteúdo bruto do Flashscore (Casa, Fora e Confrontos Diretos) — pode vir com datas, siglas e 'Mostrar mais jogos'." class="w-full bg-zinc-950 border border-zinc-800 rounded-xl p-3 text-sm"></textarea>
      <div class="flex items-center gap-4 text-sm text-zinc-400">
        <label class="flex items-center gap-2"><input id="optLower" type="checkbox" class="accent-emerald-400"> converter nomes para minúsculas</label>
        <label class="flex items-center gap-2"><input id="optResultSuffix" type="checkbox" class="accent-emerald-400"> manter sufixo de resultado ( - V/D/E) quando existir</label>
      </div>
    </section>

    <div class="flex items-center gap-3">
      <button id="btnAnalyze" class="px-4 py-2 rounded-xl bg-white text-black font-semibold hover:opacity-90 transition">Analisar</button>
      <button id="btnClear" class="px-4 py-2 rounded-xl bg-zinc-800 text-zinc-100 hover:bg-zinc-700 transition">Limpar</button>
    </div>

    <section id="detected" class="hidden bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4">
      <h3 class="font-semibold mb-2">Placar(es) detectados (após normalização)</h3>
      <div id="detectedTables" class="grid md:grid-cols-3 gap-4"></div>
      <p class="text-xs text-zinc-400 mt-3">Aqui você confere exatamente o que foi entendido a partir do texto colado (garantia de detecção ✅).</p>
    </section>

    <section id="results" class="hidden grid md:grid-cols-3 gap-4">
      <div id="cardHome" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardAway" class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
      <div id="cardH2H"  class="bg-zinc-900/60 border border-zinc-800 rounded-2xl p-4"></div>
    </section>

    <section id="decision" class="hidden bg-zinc-900/80 border border-zinc-700 rounded-2xl p-6 space-y-6">
      <div>
        <h3 class="text-xl font-bold mb-3">Veredito — BTTS</h3>
        <div id="verdictLineBTTS" class="mb-3"></div>
        <div class="grid md:grid-cols-2 gap-4 text-sm">
          <div>
            <h4 class="font-semibold mb-1">Cálculo (estilo tipster)</h4>
            <ul id="calcListBTTS" class="list-disc pl-6 space-y-1 text-zinc-300"></ul>
          </div>
          <div>
            <h4 class="font-semibold mb-1">Regras de decisão</h4>
            <ul class="list-disc pl-6 space-y-1 text-zinc-300">
              <li><span class="badge bg-emerald-900/50 text-emerald-200">BTTS Forte</span>: p ≥ 60% e Casa &amp; Fora ≥ 55%.</li>
              <li><span class="badge bg-amber-900/40 text-amber-200">BTTS Leve</span>: 52% ≤ p &lt; 60%.</li>
              <li><span class="badge bg-zinc-800 text-zinc-200">Neutro</span>: faixa intermediária não-criteriosa.</li>
              <li><span class="badge bg-rose-900/50 text-rose-200">Contra-BTTS</span>: p ≤ 48% ou ≥2 fontes ≤ 40%.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="border-t border-zinc-700 pt-6">
        <h3 class="text-xl font-bold mb-3">Veredito — Over 2.5</h3>
        <div id="verdictLineO25" class="mb-3"></div>
        <div class="grid md:grid-cols-2 gap-4 text-sm">
          <div>
            <h4 class="font-semibold mb-1">Cálculo (estilo tipster)</h4>
            <ul id="calcListO25" class="list-disc pl-6 space-y-1 text-zinc-300"></ul>
          </div>
          <div>
            <h4 class="font-semibold mb-1">Regras de decisão</h4>
            <ul class="list-disc pl-6 space-y-1 text-zinc-300">
              <li><span class="badge bg-emerald-900/50 text-emerald-200">Over Forte</span>: p ≥ 60% e GPG médio ≥ 2.70.</li>
              <li><span class="badge bg-amber-900/40 text-amber-200">Over Leve</span>: 52% ≤ p &lt; 60%.</li>
              <li><span class="badge bg-zinc-800 text-zinc-200">Neutro</span>: faixa intermediária não-criteriosa.</li>
              <li><span class="badge bg-rose-900/50 text-rose-200">Contra-Over</span>: p ≤ 48% ou ≥2 fontes ≤ 40%.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <footer class="pt-4 text-xs text-zinc-500">
      <p><strong>Observação importante:</strong> isto é um suporte estatístico amostral; não é conselho financeiro. Considere contexto (lesões, clima, odds, necessidade de resultado) antes de apostar.</p>
    </footer>
  </div>

  <script>
    // ===== Utilidades & Seletores =====
    const $ = (id) => document.getElementById(id);
    const startsWithI = (s, k) => s.trim().toLowerCase().startsWith(k.toLowerCase());
    const isScoreNum = (s) => /^\d{1,2}$/.test(s.trim());
    const isDate = (s) => /^\d{2}\.\d{2}\.\d{2}$/.test(s.trim());
    const isResultLetter = (s) => /^[VDE]$/i.test(s.trim());
    const isAllCapsShort = (s) => /^[A-Z]{2,5}$/.test(s.trim()); // SRA, LIB etc.
    const bannedLines = ["Mostrar mais jogos", "Mostrar mais", "Show more"];

    function isHeader(s){
      const t = s.trim();
      return startsWithI(t, "Últimos jogos") || startsWithI(t, "Ultimos jogos") || startsWithI(t, "Confrontos diretos");
    }
    function isNoise(t){
      if (!t.trim()) return true;
      if (bannedLines.some(b => startsWithI(t,b))) return true;
      if (isDate(t) || isAllCapsShort(t)) return true;
      return false;
    }
    function isTeamName(s){
      const t = s.trim();
      if (!t) return false;
      if (isNoise(t) || isScoreNum(t) || isResultLetter(t)) return false;
      if (!/[A-Za-zÀ-ú]/.test(t)) return false;
      if (t.length === 1) return false;
      return true;
    }
    function normalizeCase(name, lower){ return lower ? name.toLowerCase() : name; }

    // Converte sequência TeamA, TeamB, G1, G2, [V/D/E?] em "TeamA G1 x G2 TeamB"
    function parseLinesToMatches(lines, opts){
      const clean = lines.map(s=>s.replace(/\t/g,' ').trim()).filter(Boolean).filter(l => !bannedLines.some(b=>startsWithI(l,b)));
      const out = [];
      for (let i=0; i<clean.length-3; i++){
        const a = clean[i], b = clean[i+1], c = clean[i+2], d = clean[i+3];
        if (isTeamName(a) && isTeamName(b) && isScoreNum(c) && isScoreNum(d)){
          const res = clean[i+4] && isResultLetter(clean[i+4]) ? clean[i+4].toUpperCase() : null;
          out.push(`${normalizeCase(a, opts.lower)} ${c} x ${d} ${normalizeCase(b, opts.lower)}${opts.appendResult && res ? " - "+res : ""}`);
          i += (res ? 4 : 3);
        }
      }
      return {list: out};
    }

    // Divide o colado em 3 seções: 1º "Últimos jogos" → Casa; 2º "Últimos jogos" → Fora; "Confrontos diretos" → H2H
    function splitSections(all){
      const lines = all.split(/\r?\n/);
      const idxs = [];
      for (let i=0;i<lines.length;i++) if (isHeader(lines[i])) idxs.push({i, text: lines[i]});
      let secc = { casa: [], fora: [], h2h: [] };
      if (idxs.length === 0) return secc;
      const idxUJ = idxs.filter(h => startsWithI(h.text, "Últimos jogos") || startsWithI(h.text, "Ultimos jogos"));
      const idxH2H = idxs.find(h => startsWithI(h.text, "Confrontos diretos"));
      function sliceRange(start, end){ return lines.slice(start+1, end < 0 ? undefined : end); }
      if (idxUJ[0]){ const start = idxUJ[0].i; const end = idxUJ[1] ? idxUJ[1].i : (idxH2H ? idxH2H.i : -1); secc.casa = sliceRange(start, end); }
      if (idxUJ[1]){ const start = idxUJ[1].i; const end = idxH2H ? idxH2H.i : -1; secc.fora = sliceRange(start, end); }
      if (idxH2H){ const start = idxH2H.i; secc.h2h = sliceRange(start, -1); }
      return secc;
    }

    // ===== Extração de placares =====
    function extractInlineScores(lines){
      const out = [];
      const rx = /(\d{1,2})\s*[-:xX]\s*(\d{1,2})/; // 1-0, 1:0, 1 x 0
      for (const line of lines){
        const m = line.match(rx);
        if (m){
          const a = parseInt(m[1], 10), b = parseInt(m[2], 10);
          if (!isNaN(a)&&!isNaN(b)&&a<=20&&b<=20) out.push([a,b]);
        }
      }
      return out;
    }

    // ===== Estatísticas por conjunto =====
    function statsFrom(scores){
      const n = scores.length;
      if (n === 0) return {n:0, btts:0, pBTTS:NaN, over25:0, pO25:NaN, gpg:NaN, streakBTTS:0};
      let btts=0, over25=0, goals=0, streak=0;
      for (let i=0;i<n;i++){
        const [a,b] = scores[i];
        const isBTTS = a>0 && b>0;
        const isO25  = (a+b) >= 3;
        if (isBTTS) btts++;
        if (isO25)  over25++;
        streak = i===0 ? (isBTTS?1:0) : (isBTTS?streak+1:0);
        goals += a+b;
      }
      return { n, btts, pBTTS: btts/n, over25, pO25: over25/n, gpg: goals/n, streakBTTS: streak };
    }

    function pct(n){ return isFinite(n) ? (n*100).toFixed(1) + '%' : '—'; }
    function fairOdds(p){ return (p>0 ? (1/p).toFixed(2) : '—'); }

    function tableHTML(title, scores){
      if (!scores.length) return `<div class="text-zinc-500">Nenhum placar detectado.</div>`;
      const rows = scores.map(([a,b],i)=>`<tr class="hover:bg-zinc-900/50">
        <td class="px-2 py-1 text-zinc-400">#${i+1}</td>
        <td class="px-2 py-1 font-mono">${a}-${b}</td>
        <td class="px-2 py-1 ${a>0&&b>0?'text-emerald-300':'text-zinc-300'}">${a>0&&b>0?'BTTS':'—'}</td>
        <td class="px-2 py-1 ${a+b>=3?'text-emerald-300':'text-zinc-300'}">${a+b>=3?'O2.5':'—'}</td>
        <td class="px-2 py-1 text-zinc-300">${a+b}</td>
      </tr>`).join('');
      return `
        <div>
          <h4 class="font-semibold mb-2">${title}</h4>
          <table class="w-full text-sm border border-zinc-800 rounded-xl overflow-hidden">
            <thead class="bg-zinc-900/60">
              <tr>
                <th class="px-2 py-1 text-left text-zinc-400">Jogo</th>
                <th class="px-2 py-1 text-left text-zinc-400">Placar</th>
                <th class="px-2 py-1 text-left text-zinc-400">Ambos?</th>
                <th class="px-2 py-1 text-left text-zinc-400">O2.5?</th>
                <th class="px-2 py-1 text-left text-zinc-400">Gols</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }

    function cardHTML(label, st, color){
      const warn = st.n < 3 ? '<div class="text-amber-300 text-xs">Amostra pequena — resultados menos estáveis.</div>' : '';
      return `
        <div>
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">${label}</h3>
            <span class="badge ${color}">n=${st.n}</span>
          </div>
          ${warn}
          <ul class="text-sm space-y-1">
            <li>BTTS: <span class="font-semibold">${pct(st.pBTTS)}</span> (${st.btts}/${st.n})</li>
            <li>Over 2.5: <span class="font-semibold">${pct(st.pO25)}</span> (${st.over25}/${st.n})</li>
            <li>Gols por jogo: <span class="font-semibold">${isFinite(st.gpg)?st.gpg.toFixed(2):'—'}</span></li>
            <li>Streak BTTS (início da lista): <span class="font-semibold">${st.streakBTTS}</span></li>
          </ul>
        </div>`;
    }

    function decideVerdictBTTS(p, pH, pA, pD){
      let label = 'Neutro', cls = 'bg-zinc-800 text-zinc-100', emoji='⚖️';
      if (p <= 0.48 || [pH,pA,pD].filter(x=>x<=0.40).length >= 2) { label = 'Contra-BTTS'; cls='bg-rose-900/60 text-rose-100'; emoji='⛔'; }
      else if (p >= 0.60 && pH>=0.55 && pA>=0.55) { label='BTTS Forte'; cls='bg-emerald-900/60 text-emerald-100'; emoji='🔥'; }
      else if (p >= 0.52 && p < 0.60) { label='BTTS Leve'; cls='bg-amber-900/60 text-amber-100'; emoji='✨'; }
      return {label, cls, emoji};
    }
    function decideVerdictO25(p, meanG, pH, pA, pD){
      let label = 'Neutro', cls = 'bg-zinc-800 text-zinc-100', emoji='⚖️';
      if (p <= 0.48 || [pH,pA,pD].filter(x=>x<=0.40).length >= 2) { label = 'Contra-Over'; cls='bg-rose-900/60 text-rose-100'; emoji='⛔'; }
      else if (p >= 0.60 && isFinite(meanG) && meanG >= 2.70) { label='Over Forte'; cls='bg-emerald-900/60 text-emerald-100'; emoji='🔥'; }
      else if (p >= 0.52 && p < 0.60) { label='Over Leve'; cls='bg-amber-900/60 text-amber-100'; emoji='✨'; }
      return {label, cls, emoji};
    }

    // ==== NOVA LÓGICA: FREQUÊNCIA PONDERADA + POISSON (NOSSO MODELO) ====

    // weighted rate with weights [5,4,3,2,1] (most recent first)
    function weightedRateBool(arrBool){
      const weights = [5,4,3,2,1].slice(0, arrBool.length);
      const wsum = weights.reduce((a,b)=>a+b,0);
      if (wsum === 0) return 0;
      let s = 0;
      for (let i=0;i<arrBool.length;i++){
        s += (arrBool[i] ? 1 : 0) * weights[i];
      }
      return s / wsum;
    }

    function mean(arr){ return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }

    // Poisson BTTS probability
    function poissonPBTTS(lh, la){
      const p0h = Math.exp(-lh);
      const p0a = Math.exp(-la);
      return 1 - p0h - p0a + Math.exp(-(lh+la));
    }
    // Poisson Over2.5
    function poissonPOver25(lh, la){
      const lam = lh + la;
      const p_le2 = Math.exp(-lam) * (1 + lam + (lam*lam)/2);
      return 1 - p_le2;
    }

    // Estimate lambdas using simple heuristic:
    // lam_home = (avg_home_scored + avg_away_conceded) / 2 * home_adv
    // lam_away = (avg_away_scored + avg_home_conceded) / 2
    function estimateLambdas(scHome, scAway){
      // scHome entries: [homeGoals, oppGoals]
      // scAway entries: [oppGoals, awayGoals]  <-- convención adotada no parser original
      const home_scored = scHome.map(s => s[0]);
      const home_conceded = scHome.map(s => s[1]);
      const away_scored = scAway.map(s => s[1]);
      const away_conceded = scAway.map(s => s[0]);

      const avg_home_scored = mean(home_scored);
      const avg_home_conceded = mean(home_conceded);
      const avg_away_scored = mean(away_scored);
      const avg_away_conceded = mean(away_conceded);

      const lam_h = ((avg_home_scored + avg_away_conceded) / 2) * 1.03; // small home advantage
      const lam_a = ((avg_away_scored + avg_home_conceded) / 2);
      return [lam_h, lam_a];
    }

    // Main analyze function (replaces prior combination logic)
    function analyze(){
      const raw = $("taUnified").value || "";
      const lower = $("optLower").checked;
      const appendResult = $("optResultSuffix").checked;

      // 1) Normaliza → separa em Casa/Fora/H2H
      const secc = splitSections(raw);
      const casaNorm = parseLinesToMatches(secc.casa, { lower, appendResult }).list;
      const foraNorm = parseLinesToMatches(secc.fora, { lower, appendResult }).list;
      const h2hNorm  = parseLinesToMatches(secc.h2h,  { lower, appendResult }).list;

      // 2) Extrai os scores
      const scHome = extractInlineScores(casaNorm);
      const scAway = extractInlineScores(foraNorm);
      const scH2H  = extractInlineScores(h2hNorm);

      // Mostrar detecção
      $("detected").classList.remove('hidden');
      $("detectedTables").innerHTML = [
        tableHTML('CASA — placares detectados', scHome),
        tableHTML('FORA — placares detectados', scAway),
        tableHTML('H2H — placares detectados', scH2H),
      ].join('');

      // 3) Estatísticas (originais para exibição)
      const stH = statsFrom(scHome);
      const stA = statsFrom(scAway);
      const stD = statsFrom(scH2H);

      $("results").classList.remove('hidden');
      $("cardHome").innerHTML = cardHTML('CASA (últimos 5)', stH, 'bg-emerald-900/40 text-emerald-100');
      $("cardAway").innerHTML = cardHTML('FORA (últimos 5)', stA, 'bg-sky-900/40 text-sky-100');
      $("cardH2H").innerHTML  = cardHTML('H2H (últimos 5)',  stD, 'bg-amber-900/40 text-amber-100');

      // --- Nosso modelo híbrido ---
      // Frequency part: p_home_score, p_away_score using weighted recency
      // For CASA: assume team goals are first in scHome entries
      // For FORA: assume team goals are second in scAway entries (consistent com parsing original)
      const p_home_score = scHome.length ? weightedRateBool(scHome.map(s => s[0] >= 1)) : 0;
      const p_away_score = scAway.length ? weightedRateBool(scAway.map(s => s[1] >= 1)) : 0;
      const freq_btts_ind = p_home_score * p_away_score;

      // H2H BTTS frequency (weighted boolean by recency)
      const p_h2h_btts = scH2H.length ? weightedRateBool(scH2H.map(s => (s[0] > 0 && s[1] > 0))) : 0.5;
      const p_h2h_over25 = scH2H.length ? weightedRateBool(scH2H.map(s => (s[0] + s[1] >= 3))) : 0.5;

      // Poisson lambdas
      const [lam_h, lam_a] = estimateLambdas(scHome, scAway);
      const poisson_btts = poissonPBTTS(lam_h, lam_a);
      const poisson_over25 = poissonPOver25(lam_h, lam_a);

      // Final combination weights (fixed per sua solicitacao)
      // BTTS: 50% Poisson, 35% Frequency, 15% H2H
      const final_btts = 0.50 * poisson_btts + 0.35 * freq_btts_ind + 0.15 * p_h2h_btts;

      // Over2.5: 80% Poisson, 20% H2H
      const final_over25 = 0.80 * poisson_over25 + 0.20 * p_h2h_over25;

      // Prepare display: keep legacy decision UI but feed final probs
      const wH = parseFloat($("wHome").value || '0.4');
      const wA = parseFloat($("wAway").value || '0.4');
      const wD = parseFloat($("wH2H").value  || '0.2');
      const sumW = wH + wA + wD || 1;

      // For compatibility with the decision UI, compute "source" probabilities used previously (stH.pBTTS etc)
      const pH = stH.pBTTS || 0, pA = stA.pBTTS || 0, pD = stD.pBTTS || 0;
      const pH_o = stH.pO25 || 0, pA_o = stA.pO25 || 0, pD_o = stD.pO25 || 0;

      // mean goals (legacy display)
      const avgG_list = [stH.gpg, stA.gpg, stD.gpg].filter(Number.isFinite);
      const meanG = avgG_list.length ? avgG_list.reduce((a,b)=>a+b,0)/avgG_list.length : 2.6;

      // Determine verdicts using existing rules but with our final probabilities
      const {label: labB, cls: clsB, emoji: emB} = decideVerdictBTTS(final_btts, pH, pA, pD);
      const {label: labO, cls: clsO, emoji: emO} = decideVerdictO25(final_over25, meanG, pH_o, pA_o, pD_o);

      $("decision").classList.remove('hidden');

      $("verdictLineBTTS").innerHTML = `
        <div class="flex flex-wrap items-center gap-2">
          <span class="badge ${clsB}">${emB} ${labB}</span>
          <span class="text-zinc-300">Prob. combinada (modelo final): <span class="font-semibold">${pct(final_btts)}</span></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Fonte(freq): Casa ${pct(p_home_score)}, Fora ${pct(p_away_score)}</span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">H2H BTTS: <strong>${pct(p_h2h_btts)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-400">Lambdas: <strong>${lam_h.toFixed(2)}</strong> / <strong>${lam_a.toFixed(2)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Poisson BTTS: <strong>${pct(poisson_btts)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Fair odds (sem margem): <strong>${fairOdds(final_btts)}</strong></span>
        </div>`;

      $("calcListBTTS").innerHTML = `
        <li><strong>Poisson (50%)</strong> — P(BTTS) por λs: <code>${(poisson_btts*100).toFixed(1)}%</code> (λ casa=${lam_h.toFixed(2)}, λ fora=${lam_a.toFixed(2)})</li>
        <li><strong>Frequência (35%)</strong> — p_home_score=${pct(p_home_score)}, p_away_score=${pct(p_away_score)}, combinação indep = <code>${(freq_btts_ind*100).toFixed(1)}%</code></li>
        <li><strong>H2H (15%)</strong> — BTTS H2H (ponderado recência) = <code>${(p_h2h_btts*100).toFixed(1)}%</code></li>
        <li><strong>p final</strong> = 0.50·Poisson + 0.35·Freq + 0.15·H2H = <code>${(final_btts*100).toFixed(1)}%</code></li>`;

      // Over 2.5 display
      $("verdictLineO25").innerHTML = `
        <div class="flex flex-wrap items-center gap-2">
          <span class="badge ${clsO}">${emO} ${labO}</span>
          <span class="text-zinc-300">Prob. combinada (modelo final): <span class="font-semibold">${pct(final_over25)}</span></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">H2H Over2.5: <strong>${pct(p_h2h_over25)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Poisson Over2.5: <strong>${pct(poisson_over25)}</strong></span>
          <span class="text-zinc-500">|</span>
          <span class="text-zinc-300">Fair odds (sem margem): <strong>${fairOdds(final_over25)}</strong></span>
        </div>`;

      $("calcListO25").innerHTML = `
        <li><strong>Poisson (80%)</strong> — P(Over2.5) por λs = <code>${(poisson_over25*100).toFixed(1)}%</code></li>
        <li><strong>H2H (20%)</strong> — Over2.5 H2H (ponderado recência) = <code>${(p_h2h_over25*100).toFixed(1)}%</code></li>
        <li><strong>p final</strong> = 0.80·Poisson + 0.20·H2H = <code>${(final_over25*100).toFixed(1)}%</code></li>`;

      // Scroll to results (UX)
      setTimeout(()=>{ document.querySelector('#decision').scrollIntoView({behavior:'smooth'}); }, 60);
    }

    $("btnAnalyze").addEventListener('click', analyze);
    $("btnClear").addEventListener('click', () => {
      $("taUnified").value = '';
      ["results","decision","detected"].forEach(id=>$(id).classList.add('hidden'));
      $("detectedTables").innerHTML = '';
      ["cardHome","cardAway","cardH2H","verdictLineBTTS","calcListBTTS","verdictLineO25","calcListO25"].forEach(id=>{ const el = $(id); if (el) el.innerHTML = ''; });
      $("optLower").checked = false;
      $("optResultSuffix").checked = false;
    });
  </script>
</body>
</html>
